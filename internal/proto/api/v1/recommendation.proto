// Copyright (c) HashiCorp, Inc.

syntax = "proto3";

package api.v1;

option go_package = "github.com/devzero-inc/services/dakr/gen/api/v1;gen";
option java_multiple_files = true;
option java_package = "gen.api.v1";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "api/v1/common.proto";
import "api/v1/k8s.proto";

service K8sRecommendationService {
    // Cluster Stats
    // rpc GetClusterStats(GetClusterStatsRequest) returns (GetClusterStatsResponse);
    // rpc GetLatestClusterRecommendation(GetLatestClusterRecommendationRequest) returns (GetLatestClusterRecommendationResponse);

    // Node Group Stats
    rpc GetNodeGroupStats(GetNodeGroupStatsRequest) returns (GetNodeGroupStatsResponse);
    rpc GetLatestNodeGroupRecommendation(GetLatestNodeGroupRecommendationRequest) returns (GetLatestNodeGroupRecommendationResponse);
    rpc GetPreviewNodeGroupRecommendation(GetPreviewNodeGroupRecommendationRequest) returns (GetPreviewNodeGroupRecommendationResponse);

    // Workload Stats
    rpc GetWorkloadStats(GetWorkloadStatsRequest) returns (GetWorkloadStatsResponse);
    rpc GetLatestWorkloadRecommendation(GetLatestWorkloadRecommendationRequest) returns (GetLatestWorkloadRecommendationResponse);
    rpc GetPreviewWorkloadRecommendation(GetPreviewWorkloadRecommendationRequest) returns (GetPreviewWorkloadRecommendationResponse);
    rpc GetPreviewWorkloadRecommendations(GetPreviewWorkloadRecommendationsRequest) returns (GetPreviewWorkloadRecommendationsResponse);
    rpc GetRecommendationsForWorkload(GetRecommendationsForWorkloadRequest) returns (GetRecommendationsForWorkloadResponse);
    rpc GetRecommendations(GetRecommendationsRequest) returns (GetRecommendationsResponse);

    // Cluster Recommendation Policies
    // rpc CreateClusterRecommendationPolicy(CreateClusterRecommendationPolicyRequest) returns (CreateClusterRecommendationPolicyResponse);
    // rpc GetClusterRecommendationPolicy(GetClusterRecommendationPolicyRequest) returns (GetClusterRecommendationPolicyResponse);
    // rpc ListClusterRecommendationPolicies(ListClusterRecommendationPoliciesRequest) returns (ListClusterRecommendationPoliciesResponse);
    // rpc UpdateClusterRecommendationPolicy(UpdateClusterRecommendationPolicyRequest) returns (UpdateClusterRecommendationPolicyResponse);
    // rpc DeleteClusterRecommendationPolicy(DeleteClusterRecommendationPolicyRequest) returns (DeleteClusterRecommendationPolicyResponse);
    // rpc AttachClusterRecommendationPolicy(AttachClusterRecommendationPolicyRequest) returns (AttachClusterRecommendationPolicyResponse);

    // NodeGroup Recommendation Policies
    rpc CreateNodeGroupRecommendationPolicy(CreateNodeGroupRecommendationPolicyRequest) returns (CreateNodeGroupRecommendationPolicyResponse);
    rpc GetNodeGroupRecommendationPolicy(GetNodeGroupRecommendationPolicyRequest) returns (GetNodeGroupRecommendationPolicyResponse);
    rpc ListNodeGroupRecommendationPolicies(ListNodeGroupRecommendationPoliciesRequest) returns (ListNodeGroupRecommendationPoliciesResponse);
    rpc UpdateNodeGroupRecommendationPolicy(UpdateNodeGroupRecommendationPolicyRequest) returns (UpdateNodeGroupRecommendationPolicyResponse);
    rpc DeleteNodeGroupRecommendationPolicy(DeleteNodeGroupRecommendationPolicyRequest) returns (DeleteNodeGroupRecommendationPolicyResponse);
    rpc AttachNodeGroupRecommendationPolicy(AttachNodeGroupRecommendationPolicyRequest) returns (AttachNodeGroupRecommendationPolicyResponse);

    // Workload Recommendation Policies
    rpc CreateWorkloadRecommendationPolicy(CreateWorkloadRecommendationPolicyRequest) returns (CreateWorkloadRecommendationPolicyResponse);
    rpc GetWorkloadRecommendationPolicy(GetWorkloadRecommendationPolicyRequest) returns (GetWorkloadRecommendationPolicyResponse);
    rpc ListWorkloadRecommendationPolicies(ListWorkloadRecommendationPoliciesRequest) returns (ListWorkloadRecommendationPoliciesResponse);
    rpc UpdateWorkloadRecommendationPolicy(UpdateWorkloadRecommendationPolicyRequest) returns (UpdateWorkloadRecommendationPolicyResponse);
    rpc DeleteWorkloadRecommendationPolicy(DeleteWorkloadRecommendationPolicyRequest) returns (DeleteWorkloadRecommendationPolicyResponse);
    rpc AttachWorkloadRecommendationPolicy(AttachWorkloadRecommendationPolicyRequest) returns (AttachWorkloadRecommendationPolicyResponse);

    // AttachWorkloadRecommendationPolicies attaches a workload recommendation policy to multiple workloads
    rpc AttachWorkloadRecommendationPolicies(AttachWorkloadRecommendationPoliciesRequest) returns (AttachWorkloadRecommendationPoliciesResponse);

    // Workload Policy Targets (Pattern-Based Targeting)
    rpc CreateWorkloadPolicyTarget(CreateWorkloadPolicyTargetRequest) returns (CreateWorkloadPolicyTargetResponse);
    rpc GetWorkloadPolicyTarget(GetWorkloadPolicyTargetRequest) returns (GetWorkloadPolicyTargetResponse);
    rpc ListWorkloadPolicyTargets(ListWorkloadPolicyTargetsRequest) returns (ListWorkloadPolicyTargetsResponse);
    rpc UpdateWorkloadPolicyTarget(UpdateWorkloadPolicyTargetRequest) returns (UpdateWorkloadPolicyTargetResponse);
    rpc DeleteWorkloadPolicyTarget(DeleteWorkloadPolicyTargetRequest) returns (DeleteWorkloadPolicyTargetResponse);
    rpc ToggleWorkloadPolicyTargets(ToggleWorkloadPolicyTargetsRequest) returns (ToggleWorkloadPolicyTargetsResponse);
    rpc PreviewWorkloadPolicyTargetMatches(PreviewWorkloadPolicyTargetMatchesRequest) returns (PreviewWorkloadPolicyTargetMatchesResponse);
    rpc GetPreviewWorkloadPolicyTargetRecommendations(GetPreviewWorkloadPolicyTargetRecommendationsRequest) returns (GetPreviewWorkloadPolicyTargetRecommendationsResponse);
    rpc GetWorkloadsWithAttachedPolicyTargets(GetWorkloadsWithAttachedPolicyTargetsRequest) returns (GetWorkloadsWithAttachedPolicyTargetsResponse);

    // Node Policy Targets (Pattern-Based Targeting)
    rpc CreateNodeGroupPolicyTarget(CreateNodeGroupPolicyTargetRequest) returns (CreateNodeGroupPolicyTargetResponse);
    rpc GetNodeGroupPolicyTarget(GetNodeGroupPolicyTargetRequest) returns (GetNodeGroupPolicyTargetResponse);
    rpc ListNodeGroupPolicyTargets(ListNodeGroupPolicyTargetsRequest) returns (ListNodeGroupPolicyTargetsResponse);
    rpc UpdateNodeGroupPolicyTarget(UpdateNodeGroupPolicyTargetRequest) returns (UpdateNodeGroupPolicyTargetResponse);
    rpc DeleteNodeGroupPolicyTarget(DeleteNodeGroupPolicyTargetRequest) returns (DeleteNodeGroupPolicyTargetResponse);
    rpc ToggleNodeGroupPolicyTargets(ToggleNodeGroupPolicyTargetsRequest) returns (ToggleNodeGroupPolicyTargetsResponse);
    rpc PreviewNodeGroupPolicyTargetMatches(PreviewNodeGroupPolicyTargetMatchesRequest) returns (PreviewNodeGroupPolicyTargetMatchesResponse);
    rpc GetPreviewNodeGroupPolicyTargetRecommendations(GetPreviewNodeGroupPolicyTargetRecommendationsRequest) returns (GetPreviewNodeGroupPolicyTargetRecommendationsResponse);

    // Balance get recommendations
    rpc BalanceGetRecommendations(stream BalanceGetRecommendationsRequest) returns (stream BalanceGetRecommendationsResponse);

    // website recommendations for optimal instance type for node group
    rpc GetOptimalInstanceTypeForNodeGroup(GetOptimalInstanceTypeForNodeGroupRequest) returns (GetOptimalInstanceTypeForNodeGroupResponse);

    // Get attached node group policies
    rpc GetAttachedNodeGroupPolicies(GetAttachedNodeGroupPoliciesRequest) returns (GetAttachedNodeGroupPoliciesResponse);

    // Get attached workload policies
    rpc GetAttachedWorkloadPolicies(GetAttachedWorkloadPoliciesRequest) returns (GetAttachedWorkloadPoliciesResponse);

    // ListAttachedWorkloadPolicies retrieves all attached workload policies and workloads for a team
    rpc ListAttachedWorkloadPolicies(ListAttachedWorkloadPoliciesRequest) returns (ListAttachedWorkloadPoliciesResponse);

    // ListAttachedNodeGroupPolicies retrieves all attached node group policies and node groups for a team
    rpc ListAttachedNodeGroupPolicies(ListAttachedNodeGroupPoliciesRequest) returns (ListAttachedNodeGroupPoliciesResponse);

    // RecommendationEvents is a way for callers to retrieve the supported event types
    rpc RecommendationEvents(RecommendationEventsRequest) returns (RecommendationEventsResponse);

    // ApplyRecommendation is a way for people to instruct the control plane to immediately signal the relevant operator to apply a recommendation.
    rpc ApplyRecommendation(ApplyRecommendationRequest) returns (ApplyRecommendationResponse);
    
    // RecommendationApplied is a way for people to signal that a recommendation has been applied
    rpc RecommendationApplied(RecommendationAppliedRequest) returns (RecommendationAppliedResponse);

    // RetrieveSavingsForWorkload retrieves optimization information about workloads;
    rpc RetrieveSavingsForWorkload(RetrieveSavingsForWorkloadRequest) returns (RetrieveSavingsForWorkloadResponse);
}

message GetRecommendationsRequest {
    string cluster_id = 1;
    string team_id = 2;

    optional google.protobuf.Timestamp start_time = 16;
    optional google.protobuf.Timestamp end_time = 17;

    optional WorkloadFilters filters = 31; // Optional advanced filters; when set, overrides show_deleted behavior via filters.status
}

message GetRecommendationsResponse {
    repeated WorkloadRecommendation recommendations = 1;
}

message GetRecommendationsForWorkloadRequest {
    string cluster_id = 1;
    string team_id = 2;

    string workload_uid = 5;

    optional google.protobuf.Timestamp start_time = 16;
    optional google.protobuf.Timestamp end_time = 17;
}

message GetRecommendationsForWorkloadResponse {
    repeated WorkloadRecommendation recommendations = 1;
}

// Requests and responses
message GetNodeGroupStatsRequest {
    string cluster_id = 1;
    string team_id = 2;
    string node_group_name = 3;
    optional google.protobuf.Timestamp start_time = 4;
    optional google.protobuf.Timestamp end_time = 5;
}

message GetNodeGroupStatsResponse {
    string node_group_name = 1;
    string cluster_id = 2;
    string team_id = 3;
    repeated NodeStats node_stats = 4;
}

message GetOptimalInstanceTypeForNodeGroupRequest {
    string team_id = 1;
    string cluster_id = 2;
    string node_group_name = 3;

    optional google.protobuf.Timestamp start_time = 11;
    optional google.protobuf.Timestamp end_time = 12;
    optional int32 bucket_size = 13;
    
    RecommendationMode mode = 21;
}

message GetOptimalInstanceTypeForNodeGroupResponse {
    string inst_type_on_p95 = 1;
    int32 after_node_count_p95 = 2;
    float cost_per_hr_of_inst_type_on_p95 = 3;
    string inst_type_on_p99 = 11;
    int32 after_node_count_p99 = 12;
    float cost_per_hr_of_inst_type_on_p99 = 13;
    
    // Detailed reasoning explaining the recommendation logic
    optional string reasoning = 21;
}

message GetLatestNodeGroupRecommendationRequest {
    string node_group_name = 1;
    string cluster_id = 2;
    string team_id = 3;
}

message GetLatestNodeGroupRecommendationResponse {
    string node_group_name = 1;
    string cluster_id = 2;
    string team_id = 3;

    repeated string nodes_to_remove = 4;

    int32 before_node_count = 5;
    int32 after_node_count = 6;
}

message GetPreviewNodeGroupRecommendationRequest {
    string node_group_name = 1;
    string cluster_id = 2;
    string team_id = 3;
    string policy_id = 4;
}

message GetPreviewNodeGroupRecommendationResponse {
    string node_group_name = 1;
    string cluster_id = 2;
    string team_id = 3;
    string policy_id = 4;

    repeated string nodes_to_remove = 5;

    int32 before_node_count = 6;
    int32 after_node_count = 7;
}

message GetWorkloadStatsRequest {
    string cluster_id = 1;
    string team_id = 2;
    string workload_uid = 3;
    string namespace = 4;
    K8sObjectKind kind = 5;
    string name = 6;
    optional google.protobuf.Timestamp start_time = 7;
    optional google.protobuf.Timestamp end_time = 8;
}

message GetWorkloadStatsResponse {
    string workload_uid = 1;
    string namespace = 2;
    K8sObjectKind kind = 3;
    string name = 4;
    repeated ContainerStats container_stats = 5;
}

message GetLatestWorkloadRecommendationRequest {
    string cluster_id = 1;
    string team_id = 2;
    string workload_uid = 3;
    string namespace = 4;
    K8sObjectKind kind = 5;
    string name = 6;
}

message GetLatestWorkloadRecommendationResponse {
    string workload_uid = 1;
    string namespace = 2;
    K8sObjectKind kind = 3;
    string name = 4;

    repeated ContainerRecommendation container_recommendations = 5;

    int32 current_replica_count = 6;
    int32 recommended_replica_count = 7;

    repeated Toleration current_tolerations = 8;
    repeated Toleration recommended_tolerations = 9;
}

message GetPreviewWorkloadRecommendationRequest {
    string cluster_id = 1;
    string team_id = 2;
    string workload_uid = 3;
    string namespace = 4;
    K8sObjectKind kind = 5;
    string name = 6;
    string policy_id = 7;
    // Moment in time for which the recommendations are requested
    // If not set, the current time is used
    google.protobuf.Timestamp timestamp = 8;
    // Duration to look back for vertical scaling recommendations
    // If not set, defaults to policy settings, if those are not set - 24 hours
    google.protobuf.Duration vpa_lookback = 9;
    // Duration to look back for horizontal scaling recommendations
    // If not set, defaults to policy settings, if those are not set - 5 minutes
    google.protobuf.Duration hpa_lookback = 10;

    bool include_deleted = 21;
}

message GetPreviewWorkloadRecommendationResponse {
    WorkloadRecommendation rec = 1;
}

message GetPreviewWorkloadRecommendationsRequest {
    string cluster_id = 1;
    string team_id = 2;
    string policy_id = 3;
    repeated WorkloadIdentifier workloads = 4;
    // Moment in time for which the recommendations are requested
    // If not set, the current time is used
    google.protobuf.Timestamp timestamp = 5;
    // Duration to look back for vertical scaling recommendations
    // If not set, defaults to policy settings, if those are not set - 24 hours
    google.protobuf.Duration vpa_lookback = 6;
    // Duration to look back for horizontal scaling recommendations
    // If not set, defaults to policy settings, if those are not set - 5 minutes
    google.protobuf.Duration hpa_lookback = 7;

    bool include_deleted = 21;
}

message WorkloadIdentifier {
    string workload_uid = 1;
    string namespace = 2;
    K8sObjectKind kind = 3;
    string name = 4;
}

message GetPreviewWorkloadRecommendationsResponse {
    repeated GetPreviewWorkloadRecommendationResponse recommendations = 1;
}

message CreateClusterRecommendationPolicyRequest {
    string team_id = 1;
    string name = 2;
    string description = 3;

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 5;

    // The triggers for the policy, if action_trigger is on detection
    // The triggers can be:
    // - pod_creation
    // - pod_deletion
    // - pod_unschedulable
    repeated string detection_triggers = 6;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 7;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 8;

    repeated ActionTrigger action_triggers = 51;
}

message CreateClusterRecommendationPolicyResponse {
    ClusterRecommendationPolicy policy = 1;
}

message GetClusterRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
}

message GetClusterRecommendationPolicyResponse {
    ClusterRecommendationPolicy policy = 1;
}

message ListClusterRecommendationPoliciesRequest {
    string team_id = 1;
}

message ListClusterRecommendationPoliciesResponse {
    repeated ClusterRecommendationPolicy policies = 1;
}

message UpdateClusterRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
    string name = 3;
    string description = 4;

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 6;

    // The triggers for the policy, if action_trigger is on detection
    repeated string detection_triggers = 7;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 8;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 9;

    repeated ActionTrigger action_triggers = 51;
}

message UpdateClusterRecommendationPolicyResponse {
    ClusterRecommendationPolicy policy = 1;
}

message DeleteClusterRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
}

message DeleteClusterRecommendationPolicyResponse {
    bool success = 1;
}

message AttachClusterRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
    string cluster_id = 3;
    bool detach = 4;
}

message AttachClusterRecommendationPolicyResponse {
    bool success = 1;
}

message GetWorkloadsWithAttachedPolicyTargetsRequest {
    string cluster_id = 1;
    string team_id = 2;

    google.protobuf.Timestamp start_time = 11;
    google.protobuf.Timestamp end_time = 12;

    bool include_deleted = 21;
}

message GetWorkloadsWithAttachedPolicyTargetsResponse {
    repeated WorkloadIdentifier workloads = 1;
    map<string, TargetIdList> workload_target_map = 2;
}

// Helper message used by GetWorkloadsWithAttachedPolicyTargetsResponse
message TargetIdList {
    repeated string target_ids = 1;
}

message CreateNodeGroupRecommendationPolicyRequest {
    string team_id = 1;
    string name = 2;
    string description = 3;

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 5;

    // The triggers for the policy, if action_trigger is on detection
    repeated NodeGroupDetectionTrigger detection_triggers = 6;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 7;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 8;

    // The minimum number of CPUs for the node group
    optional int32 min_cpus = 9;

    // The maximum number of CPUs for the node group
    optional int32 max_cpus = 10;

    // The available machine types for the node group
    repeated string available_machine_types = 11;

    // Whether nodes in the node group can be removed
    bool can_remove_nodes = 12 [deprecated = true];

    repeated NodeGroupActionsAllowed actions = 16;

    repeated ActionTrigger action_triggers = 51;
}

message CreateNodeGroupRecommendationPolicyResponse {
    NodeGroupRecommendationPolicy policy = 1;
}

message GetNodeGroupRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
}

message GetNodeGroupRecommendationPolicyResponse {
    NodeGroupRecommendationPolicy policy = 1;
}

message ListNodeGroupRecommendationPoliciesRequest {
    string team_id = 1;
}

message ListNodeGroupRecommendationPoliciesResponse {
    repeated NodeGroupRecommendationPolicy policies = 1;
}

message UpdateNodeGroupRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
    string name = 3;
    string description = 4;

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 6;

    // The triggers for the policy, if action_trigger is on detection
    repeated NodeGroupDetectionTrigger detection_triggers = 7;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 8;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 9;

    // The minimum number of CPUs for the node group
    optional int32 min_cpus = 10;

    // The maximum number of CPUs for the node group
    optional int32 max_cpus = 11;

    // The available machine types for the node group
    repeated string available_machine_types = 12;

    // Whether nodes in node groups can be removed
    bool can_remove_nodes = 13 [deprecated = true];

    repeated NodeGroupActionsAllowed actions = 16;

    repeated ActionTrigger action_triggers = 51;
}

message UpdateNodeGroupRecommendationPolicyResponse {
    NodeGroupRecommendationPolicy policy = 1;
}

message DeleteNodeGroupRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
}

message DeleteNodeGroupRecommendationPolicyResponse {
    bool success = 1;
}

message AttachNodeGroupRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
    string cluster_id = 3;
    string node_group_name = 4;
    bool detach = 5;

    string user_id = 11;
    string user_email = 12;
    string user_sub = 13;
    string user_token = 14;
}

message AttachNodeGroupRecommendationPolicyResponse {
    bool success = 1;
}

message CreateWorkloadRecommendationPolicyRequest {
    string team_id = 1;
    WorkloadRecommendationPolicy policy = 11;
}

message CreateWorkloadRecommendationPolicyResponse {
    WorkloadRecommendationPolicy policy = 1;
}

message GetWorkloadRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
}

message GetWorkloadRecommendationPolicyResponse {
    WorkloadRecommendationPolicy policy = 1;
}

message ListWorkloadRecommendationPoliciesRequest {
    string team_id = 1;
}

message ListWorkloadRecommendationPoliciesResponse {
    repeated WorkloadRecommendationPolicy policies = 1;
}

message UpdateWorkloadRecommendationPolicyRequest {
    string team_id = 1;
    WorkloadRecommendationPolicy policy = 11;
}

message UpdateWorkloadRecommendationPolicyResponse {
    WorkloadRecommendationPolicy policy = 1;
}

message DeleteWorkloadRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
}

message DeleteWorkloadRecommendationPolicyResponse {
    bool success = 1;
}

message AttachWorkloadRecommendationPolicyRequest {
    string team_id = 1;
    string policy_id = 2;
    string cluster_id = 3;

    string workload_uid = 4;
    string namespace = 5;
    K8sObjectKind kind = 6;

    string name = 7;

    bool detach = 8;

    string user_id = 11;
    string user_email = 12;
    string user_sub = 13;
    string user_token = 14;
}

message AttachWorkloadRecommendationPolicyResponse {
    bool success = 1;
}

message AttachWorkloadRecommendationPoliciesRequest {
    string cluster_id = 1;
    string team_id = 2;
    string policy_id = 3;
    repeated WorkloadIdentifier workloads = 4;
}

message AttachWorkloadRecommendationPoliciesResponse {
    repeated WorkloadPolicyAttachment attachments = 1;
}

message WorkloadPolicyAttachment {
    string cluster_id = 1;
    string team_id = 2;
    string policy_id = 3;
    string workload_uid = 4;
    string namespace = 5;
    K8sObjectKind kind = 6;
    string name = 7;
    google.protobuf.Timestamp created_at = 8;
    google.protobuf.Timestamp updated_at = 9;
}

// WorkloadPolicyTarget Messages for Pattern-Based Targeting

message WorkloadPolicyTarget {
    string target_id = 1;
    string policy_id = 2;
    string team_id = 3;
    optional string cluster_id = 4 [deprecated = true]; // use cluster_ids
    
    string name = 5;
    string description = 6;
    int32 priority = 7;
    bool enabled = 8;
    
    // Targeting criteria (AND logic between non-null fields)
    optional LabelSelector namespace_selector = 11;   // Target namespaces by labels
    optional LabelSelector workload_selector = 12;    // Target workloads by labels  
    repeated K8sObjectKind kind_filter = 13;          // Target specific workload kinds
    optional RegexPattern name_pattern = 14;          // Target workloads by name pattern
    optional LabelSelector annotation_selector = 15;  // Target workloads by annotations
    repeated string workload_names = 16;              // Target specific workload kinds

    repeated string node_group_names = 21;            // target workloads running on specific nodes

    repeated string cluster_ids = 31;
    
    google.protobuf.Timestamp created_at = 51;
    google.protobuf.Timestamp updated_at = 52;
}

message CreateWorkloadPolicyTargetRequest {
    string team_id = 1;
    string policy_id = 2;
    optional string cluster_id = 3 [deprecated = true]; // use cluster_ids

    string name = 4;
    string description = 5;
    int32 priority = 6;
    bool enabled = 7;
    
    // Targeting criteria (AND logic between non-null fields)
    optional LabelSelector namespace_selector = 11;   // Target namespaces by labels
    optional LabelSelector workload_selector = 12;    // Target workloads by labels  
    repeated K8sObjectKind kind_filter = 13;          // Target specific workload kinds
    optional RegexPattern name_pattern = 14;           // Target workloads by name pattern
    optional LabelSelector annotation_selector = 15;   // Target workloads by annotations
    repeated string workload_names = 16;
    repeated string node_group_names = 17;

    repeated string cluster_ids = 21;
}

message CreateWorkloadPolicyTargetResponse {
    WorkloadPolicyTarget target = 1;
}

message GetWorkloadPolicyTargetRequest {
    string team_id = 1;
    string target_id = 2;
}

message GetWorkloadPolicyTargetResponse {
    WorkloadPolicyTarget target = 1;
}

message ListWorkloadPolicyTargetsRequest {
    string team_id = 1;
    optional string cluster_id = 2;
    optional string policy_id = 3; // Filter by specific policy
    optional bool enabled_only = 4; // Only return enabled targets
}

message ListWorkloadPolicyTargetsResponse {
    repeated WorkloadPolicyTarget targets = 1;
}

message UpdateWorkloadPolicyTargetRequest {
    string team_id = 1;
    string target_id = 2;
    optional string cluster_id = 3 [deprecated = true];
    
    string name = 4;
    string description = 5;
    int32 priority = 6;
    bool enabled = 7;
    
    // Targeting criteria (AND logic between non-null fields)
    optional LabelSelector namespace_selector = 11;   // Target namespaces by labels
    optional LabelSelector workload_selector = 12;    // Target workloads by labels  
    repeated K8sObjectKind kind_filter = 13;          // Target specific workload kinds
    optional RegexPattern name_pattern = 14;           // Target workloads by name pattern
    optional LabelSelector annotation_selector = 15;   // Target workloads by annotations
    repeated string workload_names = 16;

    optional string policy_id = 21; // should only be set when target needs to be attached to diff policy

    repeated string cluster_ids = 31;
}

message UpdateWorkloadPolicyTargetResponse {
    WorkloadPolicyTarget target = 1;
}

message DeleteWorkloadPolicyTargetRequest {
    string team_id = 1;
    repeated string target_ids = 2;
}

message ToggleWorkloadPolicyTargetsRequest {
    string team_id = 1;
    repeated string target_ids = 2;
    bool enabled = 3; // set enabled for all specified targets
}

message ToggleWorkloadPolicyTargetsResponse {
    bool success = 1;
}

message DeleteWorkloadPolicyTargetResponse {
    bool success = 1;
}

message PreviewWorkloadPolicyTargetMatchesRequest {
    string team_id = 1;
    string cluster_id = 2;
    
    // Targeting criteria (AND logic between non-null fields)
    optional LabelSelector namespace_selector = 3;   // Target namespaces by labels
    optional LabelSelector workload_selector = 4;    // Target workloads by labels  
    repeated K8sObjectKind kind_filter = 5;          // Target specific workload kinds
    optional RegexPattern name_pattern = 6;           // Target workloads by name pattern
    optional LabelSelector annotation_selector = 7;   // Target workloads by annotations
    repeated string workload_names = 8;
    repeated string node_group_names = 9;
}

message PreviewWorkloadPolicyTargetMatchesResponse {
    repeated WorkloadItem matched_workloads = 1;
}

message GetPreviewWorkloadPolicyTargetRecommendationsRequest {
    string team_id = 1;
    string cluster_id = 2 [deprecated = true]; // use cluster_ids
    string policy_id = 3;

    // Targeting criteria (AND logic between non-null fields)
    optional LabelSelector namespace_selector = 4;   // Target namespaces by labels
    optional LabelSelector workload_selector = 5;    // Target workloads by labels  
    repeated K8sObjectKind kind_filter = 6;          // Target specific workload kinds
    optional RegexPattern name_pattern = 7;           // Target workloads by name pattern
    optional LabelSelector annotation_selector = 8;   // Target workloads by annotations
    repeated string workload_names = 9;
    repeated string node_group_names = 10;

    bool include_deleted = 21;

    repeated string cluster_ids = 31;
}

message GetPreviewWorkloadPolicyTargetRecommendationsResponse {
    repeated WorkloadRecommendation recommendations = 1;
}

//  NodeGroupPolicyTarget Messages for Targeting

message NodeGroupPolicyTarget {
    string target_id = 1;
    string policy_id = 2;
    string team_id = 3;
    optional string cluster_id = 4;
    
    string name = 5;
    string description = 6;
    int32 priority = 7;
    bool enabled = 8;
    
    repeated string node_group_names = 9; 
    
    google.protobuf.Timestamp created_at = 51;
    google.protobuf.Timestamp updated_at = 52;
}

message CreateNodeGroupPolicyTargetRequest {
    string team_id = 1;
    string policy_id = 2;
    optional string cluster_id = 3;
    
    string name = 4;
    string description = 5;
    int32 priority = 6;
    bool enabled = 7;
    
    repeated string node_group_names = 8;
}

message CreateNodeGroupPolicyTargetResponse {
    NodeGroupPolicyTarget target = 1;
}

message GetNodeGroupPolicyTargetRequest {
    string team_id = 1;
    string target_id = 2;
}

message GetNodeGroupPolicyTargetResponse {
    NodeGroupPolicyTarget target = 1;
}

message ListNodeGroupPolicyTargetsRequest {
    string team_id = 1;
    optional string cluster_id = 2;
    optional string policy_id = 3; // Filter by specific policy
    optional bool enabled_only = 4; // Only return enabled targets
}

message ListNodeGroupPolicyTargetsResponse {
    repeated NodeGroupPolicyTarget targets = 1;
}

message UpdateNodeGroupPolicyTargetRequest {
    string team_id = 1;
    string target_id = 2;
    optional string cluster_id = 3;
    
    string name = 4;
    string description = 5;
    int32 priority = 6;
    bool enabled = 7;
    
    repeated string node_group_names = 8;
}

message UpdateNodeGroupPolicyTargetResponse {
    NodeGroupPolicyTarget target = 1;
}

message DeleteNodeGroupPolicyTargetRequest {
    string team_id = 1;
    repeated string target_ids = 2;
}

message ToggleNodeGroupPolicyTargetsRequest {
    string team_id = 1;
    repeated string target_ids = 2;
    bool enabled = 3; // set enabled for all specified targets
}

message ToggleNodeGroupPolicyTargetsResponse {
    bool success = 1;
}

message DeleteNodeGroupPolicyTargetResponse {}

message PreviewNodeGroupPolicyTargetMatchesRequest {
    string team_id = 1;
    string cluster_id = 2;
    
    repeated string node_group_names = 3;
}

message PreviewNodeGroupPolicyTargetMatchesResponse {
    repeated NodeGroup matched_node_groups = 1;
}

message GetPreviewNodeGroupPolicyTargetRecommendationsRequest {
    string team_id = 1;
    string cluster_id = 2;
    string policy_id = 3;

    repeated string node_group_names = 4;
}

message GetPreviewNodeGroupPolicyTargetRecommendationsResponse {
    repeated NodeGroupRecommendation recommendations = 1;
}

message BalanceGetRecommendationsRequest {
    oneof request {
        BalanceRegisterRequest register = 1;
        BalanceApplyRecommendationResponse apply = 2;

        // state reconciliation APIs
        ReconcileWorkload workload_meta = 11;

        // health check APIs
        OperatorHealth operator_health = 71;
        AgentHealth agent_health = 81;
    }
    string request_id = 99; // optional
}

message BalanceGetRecommendationsResponse {
    oneof response {
        NodeGroupRecommendation node_group_recommendation = 1;
        WorkloadRecommendation workload_recommendation = 2;

        // batch APIs
        BatchNodeGroupRecommendations batch_node_group_recommendations = 11;
        BatchWorkloadRecommendations batch_workload_recommendations = 12;

        // state reconciliation APIs
        WorkloadWithActiveRecommendations kind_to_namespace_to_workloads = 31; // return {kind: namespace: [workloads]}
        ReconcileResponse workload_reconcile_response = 41;
        
        HealthReport health_update_requested = 71;
    }
    string request_id = 99; // optional
}

message BatchNodeGroupRecommendations {
  repeated NodeGroupRecommendation recommendations = 1;
}

message BatchWorkloadRecommendations {
  repeated WorkloadRecommendation recommendations = 1;
}

message WorkloadWithActiveRecommendations {
    repeated WorkloadIdentifier workloads = 1; // picking this pattern since caller has to iterate over the list anyway
    // TODO support pagination
}

message ReconcileWorkload {
    K8sObjectKind kind = 1;
    string workload_name = 2;
    string namespace = 3;
    string workload_uid = 4; // for consistency + traceability
}

message ReconcileResponse {
  string request_id = 1;
  string workload_uid = 2;
  ReconcileStatus status = 3;
  optional WorkloadRecommendation updated_recommendation = 11;
}

enum ReconcileStatus {
  RECONCILE_STATUS_NOOP = 0;
  RECONCILE_STATUS_NEW_RECOMMENDATION = 1;
  RECONCILE_STATUS_STOP_TRACKING = 2;
}

message OperatorHealth {
    bool healthy = 1;
    string version = 2;

    string agent_namespace = 11;
    string agent_app_name = 12;
    
    string checkpoint_image_registry = 21;
    string checkpoint_image_repo_name = 22;
    string checkpoint_image_registry_auth_provider = 23;

    bool no_cloud_creds = 31;
    
    bool custom_scheduler = 41;

    bool argocd_patching = 51;

    int32 workload_rec_batch_size = 61;
    int32 node_group_rec_batch_size = 62;

    string svc_account_name = 71;
}

message AgentHealth {
    map<string, AgentHealthMeta> node_name_to_agent = 1;
}

message AgentHealthMeta {
    bool healthy = 1;
    string version = 2;

    bool criu_configured = 11; // signals if criu daemonset/binaries are present
    string criu_version = 12; 

    string container_runtime_version = 21;
}

// HealthReport is the request from control plane to dakr op to report health
message HealthReport {}

// Other messages

message NodeStats {
    string node_group_name = 1;
    string node_id = 2;
    string node_name = 3;
    string instance_type = 4;
    string type = 5;
    string region = 6;
    string zone = 7;

    repeated NodeMetric metrics = 8;
}

message NodeMetric {
    google.protobuf.Timestamp timestamp = 1;

    int32 cpu_capacity = 8;
    int32 cpu_usage = 9;
    int32 cpu_cost_per_hour = 10;

    int32 memory_capacity = 11;
    int32 memory_usage = 12;
    int32 memory_cost_per_hour = 13;

    int32 gpu_capacity = 14;
    int32 gpu_usage = 15;
    int32 gpu_cost_per_hour = 16;

    int32 gpu_vram_capacity = 17;
    int32 gpu_vram_usage = 18;
    int32 gpu_vram_cost_per_hour = 19;
}

message ContainerStats {
    string workload_uid = 1;
    string namespace = 2;
    K8sObjectKind kind = 3;
    string workload_name = 4;
    string container_name = 5;

    repeated ContainerMetric metrics = 6;
    ContainerSummarizedMetric summarized_metrics = 7;
}

message ContainerMetric {
    google.protobuf.Timestamp timestamp = 1;

    int32 cpu_usage = 2;
    int32 cpu_request = 3;
    int32 cpu_limit = 4;

    int32 memory_usage = 5;
    int32 memory_request = 6;
    int32 memory_limit = 7;

    int32 gpu_usage = 8;
    int32 gpu_request = 9;
    int32 gpu_limit = 10;

    int32 gpu_vram_usage = 11;
    int32 gpu_vram_request = 12;
    int32 gpu_vram_limit = 13;
}

message ContainerSummarizedMetric {
    google.protobuf.Timestamp timestamp = 1;

    Metric cpu = 2;
    Metric memory = 3;
    Metric gpu = 4;
    Metric gpu_vram = 5;
}

message Metric {
    float min = 1;
    float avg = 2;
    float max = 3;
    float p50 = 4;
    float p75 = 5;
    float p90 = 6;
    float p95 = 7;
    float p97 = 8;
    float p99 = 9;
    float p100 = 10;
    float request = 11;
    float limit = 12;
}

message ContainerRecommendation {
    string container_name = 1;

    ResourceRecommendation current_request = 2;
    ResourceRecommendation recommended_request = 3;

    ResourceRecommendation current_limit = 4;
    ResourceRecommendation recommended_limit = 5;

    double optimization_score = 6;
}

message KedaScaledObjectRecommendation {
    string uid = 1;
    int32 min_replicas = 2;
    int32 max_replicas = 3;

    string name = 11;
    string namespace = 21;
}

message ResourceRecommendation {
    int64 cpu = 1;
    int64 memory = 2;
    int64 gpu = 3;
    int64 gpu_vram = 4;

    ActionToTake cpu_action = 11;
    ActionToTake mem_action = 12; 
    ActionToTake gpu_action = 13; 
    ActionToTake gpu_vram_action = 14; 
}

enum ActionToTake {
    ACTION_TO_TAKE_SET = 0; // set to this value
    ACTION_TO_TAKE_UNSET = 1;  // set to nil
    ACTION_TO_TAKE_IGNORE = 2; // dont fuck with this
}

// The pod this Toleration is attached to tolerates any taint that matches
// the triple <key,value,effect> using the matching operator <operator>.
message Toleration {
    // Key is the taint key that the toleration applies to. Empty means match all taint keys.
    // If the key is empty, operator must be Exists; this combination means to match all values and all keys.
    // +optional
    optional string key = 1;

    // Operator represents a key's relationship to the value.
    // Valid operators are Exists and Equal. Defaults to Equal.
    // Exists is equivalent to wildcard for value, so that a pod can
    // tolerate all taints of a particular category.
    // +optional
    optional string operator = 2;

    // Value is the taint value the toleration matches to.
    // If the operator is Exists, the value should be empty, otherwise just a regular string.
    // +optional
    optional string value = 3;

    // Effect indicates the taint effect to match. Empty means match all taint effects.
    // When specified, allowed values are NoSchedule, PreferNoSchedule and NoExecute.
    // +optional
    optional string effect = 4;

    // TolerationSeconds represents the period of time the toleration (which must be
    // of effect NoExecute, otherwise this field is ignored) tolerates the taint. By default,
    // it is not set, which means tolerate the taint forever (do not evict). Zero and
    // negative values will be treated as 0 (evict immediately) by the system.
    // +optional
    optional int64 toleration_seconds = 5;
}

message ClusterRecommendationPolicy {
    string policy_id = 1;
    string team_id = 2;
    string name = 3;
    string description = 4;

    // The trigger for policy action, can be on schedule or on detection
    ActionTrigger action_trigger = 5 [deprecated = true];

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 6;

    // The triggers for the policy, if action_trigger is on detection
    // The triggers can be:
    // - pod_creation
    // - pod_deletion
    // - pod_unschedulable
    repeated string detection_triggers = 7;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 8;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 9;

    repeated ActionTrigger action_triggers = 51;
}

message NodeGroupRecommendationPolicy {
    string policy_id = 1;
    string team_id = 2;
    string name = 3;
    string description = 4;

    // The trigger for policy action, can be on schedule or on detection
    ActionTrigger action_trigger = 5 [deprecated = true];

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 6;

    // The triggers for the policy, if action_trigger is on detection
    repeated NodeGroupDetectionTrigger detection_triggers = 7;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 8;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 9;

    // The minimum number of CPUs for the node group
    optional int32 min_cpus = 10;

    // The maximum number of CPUs for the node group
    optional int32 max_cpus = 11;

    // The available machine types for the node group
    repeated string available_machine_types = 12;

    // Whether nodes in the node group can be removed
    bool can_remove_nodes = 13 [deprecated = true];

    repeated NodeGroupActionsAllowed actions = 16;

    // default policy set by platform
    bool is_default_policy = 51;
    
    // List of composite keys (clusterId+nodeGroupName) attached to this policy
    repeated string node_group_names = 57;

    repeated ActionTrigger action_triggers = 71;
}

message VerticalScalingOptimizationTarget {
    // Whether the optimization target is enabled
    bool enabled = 1;

    // The minimum request value that can be recommended
    optional int64 min_request = 11;

    // The maximum request value that can be recommended
    optional int64 max_request = 12;

    // (default: 1) can be used for workloads with higher SLOs to maintain performance.
    optional float overhead_multiplier = 21;

    optional bool limits_adjustment_enabled = 26;
}

message HorizontalScalingOptimizationTarget {
    // Whether the optimization target is enabled
    bool enabled = 1;
    
    // The minimum number of replicas for the optimization target
    optional int32 min_replicas = 11;

    // The maximum number of replicas for the optimization target
    optional int32 max_replicas = 12;
}

message WorkloadRecommendationPolicy {
    string policy_id = 1;
    string team_id = 2;
    string name = 3;
    string description = 4;

    // The trigger for policy action, can be on schedule or on detection
    ActionTrigger action_trigger = 5 [deprecated = true];

    // The cron schedule for the policy, if action_trigger is on schedule
    optional string cron_schedule = 6;

    // The triggers for the policy, if action_trigger is on detection
    repeated WorkloadDetectionTrigger detection_triggers = 7;

    // The mode for the recommendation, can be balanced, aggressive, or conservative
    RecommendationMode recommendation_mode = 8;

    VerticalScalingOptimizationTarget cpu_vertical_scaling = 9;
    VerticalScalingOptimizationTarget memory_vertical_scaling = 10;
    VerticalScalingOptimizationTarget gpu_vertical_scaling = 11;
    VerticalScalingOptimizationTarget gpu_vram_vertical_scaling = 12;

    HorizontalScalingOptimizationTarget horizontal_scaling = 13;

    // The duration of the loopback window, this is the period of time to look back for resource usage data
    optional int32 loopback_period_seconds = 14;

    // Startup period of the workload, this is the period of time to ignore resource usage data after the workload is started
    optional int64 startup_period_seconds = 15;

    // Whether live migration is enabled for the workload policy.
    bool live_migration_enabled = 31;

    // default policy set by platform
    bool is_default_policy = 51;
    
    // List of workload UIDs attached to this policy
    repeated string workload_uids = 57;

    // ordered list of scheduler plugins
    repeated string scheduler_plugins = 61;
    optional string defragmentation_schedule = 62; // only relevant when dz-scheduler set

    repeated ActionTrigger action_triggers = 71;

    bool is_request_override_enabled = 80;
}

message BalanceRegisterRequest {
    string team_id = 1;
    string cluster_id = 2;
    string version = 11;
    optional BalanceFeatures features = 12;
}

message BalanceFeatures {
    bool live_migration = 1;
    // only batched workload recommendations in responses -- server impl defaults to 1 if not included
    optional int32 batch_workload_recommendations_size = 2;
    // only batched node recommendations in responses -- server impl defaults to 1 if not included
    optional int32 batch_node_group_recommendations_size = 3;
    // when this flag is set, operator will only send a health report, and not accept any other requests from the server
    bool operator_send_health_report_only = 4;
}

message BalanceApplyRecommendationResponse {
    string recommendation_id = 1;
    RecommendationType type = 2;
    bool success = 3;
    optional string error = 4;
}

message NodeGroupRecommendation {
    string recommendation_id = 1;
    string node_group_name = 2;
   
    repeated string nodes_to_remove = 3;

    google.protobuf.Timestamp timestamp = 4;

    uint32 current_node_count = 5;
    uint32 desired_node_count = 6;

    optional NodeGroupRecommendationPolicy policy = 61;
}

message WorkloadRecommendation {
    string recommendation_id = 1;
    string workload_uid = 2;
    string namespace = 3;
    K8sObjectKind kind = 4;
    string name = 5;
    
    repeated ContainerRecommendation container_recommendations = 6;

    int32 current_replica_count = 7;
    int32 recommended_replica_count = 8;

    google.protobuf.Timestamp timestamp = 9;

    
    repeated KedaScaledObjectRecommendation keda_scaled_object_recommendation = 10;
    optional string cluster_id = 11;

    // The label selector for the workload
    optional LabelSelector label_selector = 20;

    // whether this recommendation should be applied using live migration
    bool use_live_migration = 21;

    optional string reasoning = 31; 

    repeated Toleration current_tolerations = 41;
    repeated Toleration recommended_tolerations = 42; 

    optional RecommendationStatus status = 51;

    optional WorkloadRecommendationPolicy policy = 61;
    optional string policy_id = 62;

    optional WorkloadPolicyTarget policy_target = 71;
    optional string policy_target_id = 72;

    ActionToTake replica_count_action = 81; // suggests if operator should set recommended_replica_count
}

enum RecommendationStatus {
  RECOMMENDATION_STATUS_UNSPECIFIED = 0;
  RECOMMENDATION_STATUS_PENDING = 1;
  RECOMMENDATION_STATUS_APPLIED = 2 [deprecated = true]; // Deprecated: Applied is now moving to applied-on-schedule or applied-on-detection
  RECOMMENDATION_STATUS_FAILED = 3  [deprecated = true]; // Deprecated: Applied is now moving to applied-on-schedule or applied-on-detection
  RECOMMENDATION_STATUS_PREVIEW = 4;

  RECOMMENDATION_STATUS_CRD_SAVED_SUCCESS = 11;
  RECOMMENDATION_STATUS_CRD_SAVED_FAIL = 12;  
  
  RECOMMENDATION_STATUS_APPLIED_ON_SCHEDULE_SUCCESS = 21;
  RECOMMENDATION_STATUS_APPLIED_ON_SCHEDULE_FAIL = 22;
  
  RECOMMENDATION_STATUS_APPLIED_ON_TRIGGER_SUCCESS = 31;
  RECOMMENDATION_STATUS_APPLIED_ON_TRIGGER_FAIL = 32;
}

message GetAttachedNodeGroupPoliciesRequest {
    string team_id = 1;
    string cluster_id = 2;
    string node_group_name = 3;
}

message GetAttachedNodeGroupPoliciesResponse {
    repeated NodeGroupRecommendationPolicy policies = 1;
}

message GetAttachedWorkloadPoliciesRequest {
    string team_id = 1;
    string cluster_id = 2;
    string workload_uid = 3;
    K8sObjectKind kind = 4; // The kind of workload

    bool include_deleted = 11;
}

message GetAttachedWorkloadPoliciesResponse {
    WorkloadRecommendationPolicyGroup relevant_policies = 1;
    map<string, WorkloadPolicyTargetGroup> policy_id_to_matched_targets = 2;
}

message WorkloadRecommendationPolicyGroup {
    repeated WorkloadRecommendationPolicy policies = 1;
}

message WorkloadPolicyTargetGroup {
    repeated WorkloadPolicyTarget targets = 1;
}

message WorkloadIdentifiers {
    repeated WorkloadIdentifier workloads = 1;
}

message WorkloadPolicies {
    WorkloadIdentifier workload = 1;
    repeated WorkloadRecommendationPolicy policies = 2;
}

// ListAttachedWorkloadPoliciesRequest is used to fetch all attached workload policies and workloads for a team.
// All parameters except team_id are optional filters.
message ListAttachedWorkloadPoliciesRequest {
    string team_id = 1; // Unique identifier for the team.
    repeated string cluster_ids = 2; // Optional list of cluster IDs to filter by specific clusters.
    repeated string policy_ids = 3; // Optional list of policy IDs to filter by specific policies.
    repeated string workload_uids = 4; // Optional list of workload UIDs to filter by specific workloads.
}

// ListAttachedWorkloadPoliciesResponse contains all attached policies and workloads with their relationships.
message ListAttachedWorkloadPoliciesResponse {
    map<string, WorkloadRecommendationPolicy> policy_map = 1; // Map of policy ID to WorkloadRecommendationPolicy
    map<string, WorkloadItem> workload_map = 2; // Map of workload UID to WorkloadItem
}

// ListAttachedNodeGroupPoliciesRequest is used to fetch all attached node group policies and node groups for a team.
// All parameters except team_id are optional filters.
message ListAttachedNodeGroupPoliciesRequest {
    string team_id = 1; // Unique identifier for the team.
    repeated string cluster_ids = 2; // Optional list of cluster IDs to filter by specific clusters.
    repeated string policy_ids = 3; // Optional list of policy IDs to filter by specific policies.
    repeated string node_group_names = 4; // Optional list of node group names to filter by specific node groups.
}

// ListAttachedNodeGroupPoliciesResponse contains all attached policies and node groups with their relationships.
message ListAttachedNodeGroupPoliciesResponse {
    map<string, NodeGroupRecommendationPolicy> policy_map = 1; // Map of policy ID to NodeGroupRecommendationPolicy
    map<string, NodeGroupItem> node_group_map = 2; // Map of node group name to NodeGroupItem
}

// NodeGroupItem represents a node group and its policy attachments.
message NodeGroupItem {
    string name = 1; // Name of the node group.
    string cluster_id = 2; // Cluster ID where the node group exists.
    repeated string policy_ids = 3; // List of policy IDs attached to this node group.
}

message RecommendationAppliedRequest {
    string team_id = 1;
    string cluster_id = 2;

    string recommendation_id = 11;
    optional K8sObjectKind kind = 12; // if set, means its workload
}

message RecommendationAppliedResponse {
}

message ApplyRecommendationRequest {
    string team_id = 1;
    string cluster_id = 2;

    string recommendation_id = 11;
    optional K8sObjectKind kind = 12; // if set, means its workload
}

message ApplyRecommendationResponse {
}

message RecommendationEventsRequest {}

message RecommendationEventsResponse {
    repeated string events = 1;
}

// RetrieveSavingsForWorkloadRequest is used to fetch autoscaling impact information for workloads in a cluster.
message RetrieveSavingsForWorkloadRequest {
    string team_id = 1; // Unique identifier for the team.
    string cluster_id = 2; // Unique identifier for the cluster.
    string kind = 3; // Kind of the workload (e.g., Deployment, StatefulSet).
    string uid = 4; // Unique identifier for the workload.

    google.protobuf.Timestamp start_time = 5;
    google.protobuf.Timestamp end_time = 6;

    bool include_deleted = 11;
    bool include_get_workload_resp = 12;
}

message RetrieveSavingsForWorkloadResponse {
    SavingsTimeSeries savings = 1;
    optional GetWorkloadResponse get_workload_resp = 11;
}

// Enums

enum ActionTrigger {
    ACTION_TRIGGER_UNSPECIFIED = 0;
    ACTION_TRIGGER_MANUAL = 1;
    ACTION_TRIGGER_ON_SCHEDULE = 2;
    ACTION_TRIGGER_ON_DETECTION = 3;
}

enum WorkloadDetectionTrigger {
    DETECTION_TRIGGER_UNSPECIFIED = 0;
    DETECTION_TRIGGER_POD_CREATION = 1;
    DETECTION_TRIGGER_POD_UPDATE = 2;
}

enum NodeGroupDetectionTrigger {
    NODE_GROUP_DETECTION_TRIGGER_UNSPECIFIED = 0;
    NODE_GROUP_DETECTION_TRIGGER_FAILED_SCHEDULING_POD_UNSCHEDULABLE = 1;
}

enum NodeGroupActionsAllowed {
    NODE_GROUP_ACTIONS_ALLOWED_UNSPECIFIED = 0;
    NODE_GROUP_ACTIONS_ALLOWED_ADD_NODES = 5;
    NODE_GROUP_ACTIONS_ALLOWED_REMOVE_NODES = 10;
    NODE_GROUP_ACTIONS_ALLOWED_ADD_SPOT_INSTANCES = 15;
    NODE_GROUP_ACTIONS_ALLOWED_CHANGE_INSTANCE_SIZES_WITHIN_FAMILY = 20;
    NODE_GROUP_ACTIONS_ALLOWED_INTRODUCE_ALTERNATIVE_FAMILIES = 25;
}

enum RecommendationMode {
    RECOMMENDATION_MODE_UNSPECIFIED = 0;
    RECOMMENDATION_MODE_BALANCED = 1;
    RECOMMENDATION_MODE_AGGRESSIVE = 2;
    RECOMMENDATION_MODE_CONSERVATIVE = 3;
}

enum RecommendationType {
    RECOMMENDATION_TYPE_UNSPECIFIED = 0;
    RECOMMENDATION_TYPE_WORKLOAD = 1;
    RECOMMENDATION_TYPE_NODE_GROUP = 2;
}
